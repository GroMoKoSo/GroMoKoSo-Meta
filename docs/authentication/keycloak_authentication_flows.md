# Keycloak Authentication Flows Overview
>This document provides an overview of the various authentication flows supported by Keycloak. 

>Most of it was generated by **ChatGPT** and has not been independently verified for accuracy. Please review and validate before relying on it for production use.

**TLDR**
- **Standard Flow:** Use for most web apps.
- **Direct Access Grants:** Avoid unless legacy.
- **Implicit Flow:** Deprecated.
- **Service Accounts:** Machine-to-machine.
- **Token Exchange:** Re-issuing tokens for other services.
- **Device Flow:** Devices without browsers/keyboards.
- **CIBA:** Asynchronous login, push-based approval.

## Standard Flow (Authorization Code Flow)

- **Use case:** Web apps (frontend + backend) where security is important.
- **How it works:**
    1. The user is redirected to Keycloak’s login page.
    2. After successful login, Keycloak redirects back with an authorization code.
    3. The app exchanges this code for tokens (Access Token, ID Token, Refresh Token).
- **Why:** Tokens are never exposed in the browser URL. Safer.
- **Best practice for most apps.**

## Direct Access Grants (Resource Owner Password Credentials Grant)

- **Use case:** Legacy/mobile apps where the app directly collects the username & password.
- **How it works:**
    1. The app directly sends username + password to Keycloak’s token endpoint.
    2. Keycloak returns tokens in response.
- **Why:** Simple, but not secure (the app handles raw credentials).
- **Best practice:** Avoid if possible, only use when redirect-based login isn’t possible.

## Implicit Flow

- **Use case:** Old single-page apps (SPAs) without a backend.
- **How it works:**
    1. Tokens are returned directly in the redirect URL (no code exchange).
- **Why:** Faster but less secure (tokens visible in the browser address bar, vulnerable to interception).
- **Best practice:** Deprecated. Replace with the Authorization Code Flow with PKCE for SPAs.

## Service Account Roles (Client Credentials Flow)

- **Use case:** Machine-to-machine communication (no user).
- **How it works:**
    1. The client authenticates itself with Keycloak (using client_id + client_secret).
    2. Keycloak returns an Access Token.
- **Why:** Useful for backend services, scheduled jobs, microservices. No user context.

## Standard Token Exchange

- **Use case:** Exchanging one token for another (different audience, different scopes).
- **How it works:**
    1. App sends a valid token to Keycloak.
    2. Requests a new token (maybe for a different client or service).
- **Why:** Used in multi-service architectures, when one service needs a token that’s valid for another service.

## OAuth 2.0 Device Authorization Grant (Device Flow)

- **Use case:** Devices without a browser/keyboard (smart TVs, CLI tools).
- **How it works:**
    1. Device shows a code + URL to the user.
    2. User goes to the URL on another device, logs in, and enters the code.
    3. Device polls Keycloak until the login is confirmed, then receives tokens.
- **Why:** Secure way to authenticate users on limited devices.

## OIDC CIBA Grant (Client-Initiated Backchannel Authentication)

- **Use case:** Login without redirecting the user, often for mobile banking / telecom.
- **How it works:**
    1. The client requests authentication from Keycloak via backchannel.
    2. Keycloak pushes a login request/notification to the user (e.g. via an app or SMS).
    3. Once approved, Keycloak tells the client the user is authenticated.
- **Why:** Useful for strong, asynchronous user authentication.
