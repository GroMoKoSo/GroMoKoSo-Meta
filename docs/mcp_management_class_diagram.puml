@startuml "McpManagement class diagram"
left to right direction

package controller {
    class ToolController <<RestController>> {
        + addTool(tool: ToolSpecification)
        + deleteTool(id: String)
    }

    class WellKnownMetadataController <<RestController>> {
        + getProtectedResourceMetadata(): Map<String, Object>
    }

    class McpHandler <<Component>> {
        - mcpServerManager: McpServerManager

        + McpHandler(mcpServerManager: McpServerManager)

        + handleRequest(request: ServerRequest): ServerResponse
    }
}

package service {
    class McpServerManager <<Service>> {
        - serverProvider: GroMoKoSoMcpServerProvider
        - toolRepository: ToolRepository
        - userManagement: UserManagementClient

        - servers: Map<String, GroMoKoSoMcpServer>

        + McpServerManager(serverProvider: GroMoKoSoMcpServerProvider, toolRepository: ToolRepository, userManagement: UserManagementClient)

        + getServerForUser(user: User): GroMoKoSoMcpServer
    }

    note left of McpServerManager::servers
        Map between user_id/username and server instance
    end note

    class ToolService <<Service>> {
        + addTool(tool: ToolSpecification)
        + deleteTool(id: String)
        + getTools(): List<ToolSpecification>
    }


    class ToolFactory <<Component>> {
        - invokeTool(args: Object... ): Object
        + create(tool: Tool): McpServerFeatures.AsyncToolSpecification
    }
}

package model {

    together {

        class GroMoKoSoMcpServer {
            - server: McpAsyncServer
            - router: RouterFunction

            GroMoKoSoMcpServer(server: McpAsyncServer, router: RouterFunction)
            + handle(request: ServerRequest): ServerResponse
            + close()

            + addToolSet(toolSet: ToolSet)
            + addTool(tool: Tool)
        }

        class GroMoKoSoMcpServerProvider <<Component>> {

            - toolBuilder: ToolBuilder

            + GroMoKoSoMcpServerBuilder(toolBuilder: ToolBuilder)
            + builder()
        }

        class GroMoKoSoMcpServerSpecification {

            - name: String
            - tools: List<McpServerFeatures.AsyncToolSpecification>

            - GroMoKoSoMcpServerSpecification()
            + name(name: String): GroMoKoSoMcpServerSpecification
            + addTool(tool: Tool): GroMoKoSoMcpServerSpecification
            + addToolSet(toolSet: ToolSet): GroMoKoSoMcpServerSpecification
            + build(): GroMoKoSoMcpServer
        }

        GroMoKoSoMcpServerProvider +-- GroMoKoSoMcpServerSpecification
    }


    class ToolSet <<Entity>> {
        name: String
        description: String
        tools: List<Tool>
    }

    class Tool <<Entity>> {
        name: String
        description: String
        endpoint: String
        parameters: List<Parameter>
    }

    class Parameter <<Entity>> {
        name: String
        description: String
        type: String
    }
}

package repository {
    class ToolRepository <<Repository>> {
        + save(tool: ToolSpecification)
        + delete(id: String)
        + findAll(): List<ToolSpecification>
    }
}

package client {

    class ApiManagementClient <<Component>> {
        + call(args: Object...): String
    }

    class UserManagementClient <<Component>> {
        + getToolsForUser(userId: String): List<ToolSpecification>
    }
}

package security {
    class OAuthTokenHolder {
        - {static} holder: InheritableThreadLocal<String>

        + {static} set(token: String)
        + {static} get(): String
        + {static} clear()
    }

    class AccessTokenExtractor {
        + extractAccessToken(): Jwt
    }

    class OAuthChallengeEntryPoint <<Component>> {
        + {static} REALM: String
        + {static} RESOURCE_METADATA: String

        + commence(request: HttpServletRequest, response: HttpServletResponse, authException: AuthenticationException)
    }
}

package configuration {
    class SecurityConfig <<Configuration>> {
        - challengeEntryPoint: OAuthChallengeEntryPoint
        + SecurityConfig(entryPoint: OAuthChallengeEntryPoint)

        + <<Bean>> filterChain(http: HttpSecurity): SecurityFilterChain
    }

    class ReactorElasticBoundConfig <<Configuration>> {
        + <<PostConstruct>> init()
    }

    class McpRouterConfig <<Configuration>> {
        + <<Bean>> mcpRoutes(handler: McpRequestHandler): RouterFunction<ServerResponse>
    }
}

@enduml